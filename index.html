<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ANUBIS — A Representation-Centric Benchmark</title>
  <meta name="description" content="ANUBIS — a representation-centric multi-view skeleton-action benchmark. Click to open the full resources on Notion." />
  <!-- Open Graph (replace og:image with a real URL for social shares) -->
  <meta property="og:title" content="ANUBIS — A Representation-Centric Benchmark" />
  <meta property="og:description" content="102 classes · multi-view · privacy-friendly dataset. Open the Notion page for details." />
  <meta property="og:image" content="https://your-site.com/og-image.png" />
  <meta property="og:type" content="website" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-gradient: radial-gradient(1200px 800px at 20% -10%, rgba(61,156,255,.35), transparent 55%),
                   radial-gradient(1000px 600px at 120% 20%, rgba(255,61,182,.25), transparent 55%),
                   linear-gradient(180deg, #0B1020 0%, #080B16 100%);
      --accent-from: #6EE7F9;
      --accent-to: #C084FC;
      --text-main: #E5F0FF;
      --text-dim: #A9B6D3;
      --button-bg: rgba(255,255,255,0.92);
      --max-width: 1100px;
    }

    html,body{
      height:100%;
      margin:0;
      font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      background: var(--bg-gradient);
      color: var(--text-main);
    }

    /* Layout */
    .hero{
      min-height:92vh;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
      padding:48px 20px;
    }
    /* Canvas fills hero */
    canvas#flowCanvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      z-index:0;
    }

    .content{
      position:relative;
      z-index:2;
      text-align:center;
      max-width:var(--max-width);
      width:100%;
      margin:0 auto;
      padding: 20px;
    }

    h1{
      margin:0;
      font-weight:800;
      letter-spacing:-0.02em;
      font-size:48px;
      line-height:1.02;
      color:var(--text-main);
    }

    @media (min-width:900px){
      h1{ font-size:72px; }
    }

    .title-gradient{
      display:block;
      background-image: linear-gradient(90deg,var(--accent-from), var(--accent-to));
      -webkit-background-clip:text;
      background-clip:text;
      color:transparent;
      -webkit-text-fill-color:transparent;
      margin-top:6px;
    }

    p.lead{
      margin:18px auto 0;
      color:var(--text-dim);
      max-width:820px;
      font-size:18px;
      line-height:1.6;
    }

    .cta{
      margin-top:28px;
      display:inline-flex;
      align-items:center;
      gap:10px;
      text-decoration:none;
      padding:12px 22px;
      border-radius:999px;
      background:var(--button-bg);
      color:#0f1724;
      font-weight:600;
      box-shadow:0 10px 30px rgba(50,200,255,0.06), 0 4px 10px rgba(0,0,0,0.35);
      transition:transform .16s ease, box-shadow .16s ease, opacity .16s ease;
    }
    .cta:focus{ outline:3px solid rgba(110,231,249,0.22); outline-offset:3px; }
    .cta:hover{ transform:translateY(-4px); box-shadow:0 18px 38px rgba(50,200,255,0.09); }

    /* small accessibility note (visually subtle) */
    .note{
      margin-top:12px;
      color:rgba(255,255,255,0.45);
      font-size:12px;
    }

    /* reduced motion: minimize animations */
    @media (prefers-reduced-motion: reduce){
      .cta{ transition:none; }
    }

    /* small responsive tweak */
    @media (max-width:520px){
      h1{ font-size:34px; }
      .title-gradient{ font-size:28px; }
      p.lead{ font-size:15px; }
    }

  </style>
</head>
<body>
  <main class="hero" role="main" aria-label="ANUBIS landing">
    <!-- Canvas animation background -->
    <canvas id="flowCanvas" role="img" aria-label="Abstract multi-view motion visualization"></canvas>

    <!-- Minimal content -->
    <div class="content">
      <h1>
        ANUBIS
        <span class="title-gradient">A Representation-Centric Benchmark</span>
      </h1>

      <p class="lead">Discover a privacy-friendly, multi-view benchmark for skeleton-based action recognition. Open the Notion page for dataset details, benchmarks, and resources.</p>

      <div>
        <a id="notionBtn" class="cta" href="https://YOUR_NOTION_LINK_HERE" target="_blank" rel="noopener noreferrer" aria-label="Open Notion page with ANUBIS dataset and benchmarks">
          Open Notion Page
        </a>
      </div>

      <div class="note" aria-hidden="true">Animations respect your system's reduced-motion setting.</div>
    </div>
  </main>

  <script>
    /*
      Flow field particle background
      - Adapted for vanilla JS from earlier prototype
      - Replace YOUR_NOTION_LINK_HERE in the DOM if needed
      - Customization points documented below
    */

    (function(){
      const canvas = document.getElementById('flowCanvas');
      const ctx = canvas.getContext('2d', { alpha: true });
      let DPR = Math.max(1, window.devicePixelRatio || 1);
      let W = 0, H = 0;
      let particles = [];
      let rafId = null;
      let t = 0;
      const MAX_PARTICLES = 220; // hard cap for desktop; reduce if performance issues
      const AREA_PER_PARTICLE = 50000; // larger => fewer particles (pixel^2 per particle)

      // reduced motion
      const reducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // pointer state
      const pointer = { x: 0, y: 0, active: false };

      function resize(){
        DPR = Math.max(1, window.devicePixelRatio || 1);
        W = Math.max(300, Math.floor(canvas.clientWidth * DPR));
        H = Math.max(200, Math.floor(canvas.clientHeight * DPR));
        canvas.width = W;
        canvas.height = H;
        ctx.setTransform(1,0,0,1,0,0); // reset transform
        // recompute particle count
        const area = (canvas.clientWidth * canvas.clientHeight);
        const desired = Math.max(24, Math.floor(area / AREA_PER_PARTICLE));
        const count = Math.min(MAX_PARTICLES, Math.max(24, desired));
        // rebuild particles preserving some attributes
        const old = particles;
        particles = new Array(count).fill(0).map((_,i)=>{
          const carry = old[i];
          if (carry) {
            return {
              x: carry.x,
              y: carry.y,
              vx: carry.vx,
              vy: carry.vy,
              life: carry.life,
              age: carry.age,
              hue: carry.hue
            };
          }
          return {
            x: Math.random() * W,
            y: Math.random() * H,
            vx: (Math.random() - 0.5) * 0.6,
            vy: (Math.random() - 0.5) * 0.6,
            life: Math.random() * 200 + 100,
            age: 0,
            hue: Math.random() * 60 + 190
          };
        });
        // draw initial static background
        drawStaticBackground();
      }

      function drawStaticBackground(){
        // static dark base — used on resize and reduced-motion fallback
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(9,12,24,1)';
        ctx.fillRect(0,0,W,H);
        // add subtle radial halos
        const g1 = ctx.createRadialGradient(W*0.2, H*0.05, 0, W*0.2, H*0.05, Math.max(W,H)*0.9);
        g1.addColorStop(0, 'rgba(61,156,255,0.12)');
        g1.addColorStop(1, 'rgba(61,156,255,0)');
        ctx.fillStyle = g1;
        ctx.fillRect(0,0,W,H);

        const g2 = ctx.createRadialGradient(W*1.2, H*0.18, 0, W*1.2, H*0.18, Math.max(W,H)*1.1);
        g2.addColorStop(0, 'rgba(255,61,182,0.08)');
        g2.addColorStop(1, 'rgba(255,61,182,0)');
        ctx.fillStyle = g2;
        ctx.fillRect(0,0,W,H);
        ctx.restore();
      }

      function onPointerMove(e){
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        pointer.x = (clientX - rect.left) * DPR;
        pointer.y = (clientY - rect.top) * DPR;
        pointer.active = true;
      }
      function onPointerLeave(){ pointer.active = false; }

      // pause when page hidden
      function onVisibilityChange(){ 
        if (document.hidden) cancelAnimationFrame(rafId);
        else rafId = requestAnimationFrame(loop);
      }

      function loop(){
        if (reducedMotion) return; // do not run loop when user requests reduced motion
        // trail / fade
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(9,12,24,0.08)';
        ctx.fillRect(0,0,W,H);

        ctx.globalCompositeOperation = 'lighter';
        // update particles
        particles.forEach((p,i)=>{
          const angle = Math.sin((p.x + t * 0.6) * 0.002) + Math.cos((p.y - t * 0.4) * 0.002);
          p.vx += Math.cos(angle) * 0.04;
          p.vy += Math.sin(angle) * 0.04;

          if (pointer.active) {
            const dx = (pointer.x - p.x);
            const dy = (pointer.y - p.y);
            const dist2 = dx*dx + dy*dy + 1e-3;
            const force = Math.min(1.2, 20000 / dist2);
            p.vx += (dx/Math.sqrt(dist2)) * force * 0.08;
            p.vy += (dy/Math.sqrt(dist2)) * force * 0.08;
          }

          // friction & speed cap
          const spd = Math.sqrt(p.vx*p.vx + p.vy*p.vy) + 1e-6;
          const max = 2.2;
          if (spd > max) {
            p.vx = (p.vx / spd) * max;
            p.vy = (p.vy / spd) * max;
          }
          p.vx *= 0.985;
          p.vy *= 0.985;

          const oldx = p.x, oldy = p.y;
          p.x += p.vx;
          p.y += p.vy;

          // bounds
          if (p.x < 0 || p.x > W) { p.vx *= -1; p.x = Math.max(0, Math.min(W, p.x)); }
          if (p.y < 0 || p.y > H) { p.vy *= -1; p.y = Math.max(0, Math.min(H, p.y)); }

          // draw
          const alpha = 0.35 + 0.35 * Math.sin((t + i) * 0.01);
          // hue cycles slowly
          const hue = (p.hue + (t * 0.05)) % 360;
          ctx.strokeStyle = `hsla(${hue}, 90%, 65%, ${alpha})`;
          ctx.lineWidth = 1.0 * DPR;
          ctx.beginPath();
          ctx.moveTo(oldx, oldy);
          ctx.lineTo(p.x, p.y);
          ctx.stroke();

          // life
          p.age++;
          if (p.age > p.life) {
            p.x = Math.random() * W;
            p.y = Math.random() * H;
            p.vx = (Math.random() - 0.5) * 0.6;
            p.vy = (Math.random() - 0.5) * 0.6;
            p.age = 0;
            p.life = Math.random() * 200 + 100;
          }
        });

        t += 1;
        rafId = requestAnimationFrame(loop);
      }

      // init / attach events
      function init(){
        // size first
        resize();
        // pointer
        window.addEventListener('mousemove', onPointerMove, { passive:true });
        window.addEventListener('touchstart', onPointerMove, { passive:true });
        window.addEventListener('touchmove', onPointerMove, { passive:true });
        window.addEventListener('mouseleave', onPointerLeave, { passive:true });
        window.addEventListener('touchend', onPointerLeave, { passive:true });
        // resize
        window.addEventListener('resize', () => {
          // debounce small resize bursts
          clearTimeout(window._flow_resize_timer);
          window._flow_resize_timer = setTimeout(resize, 120);
        }, { passive:true });

        // visibility change pause/resume
        document.addEventListener('visibilitychange', onVisibilityChange, false);

        // initial draw
        drawStaticBackground();

        // start animation if allowed
        if (!reducedMotion) rafId = requestAnimationFrame(loop);
      }

      // start
      init();

      // cleanup on unload (best-effort)
      window.addEventListener('pagehide', () => {
        cancelAnimationFrame(rafId);
      });

      // expose a small API for runtime tweaks (optional)
      window.ANUBIS_FLOW = {
        setMaxParticles(n){
          // only accept integer
          const v = Math.max(12, Math.min(1000, Math.floor(n)));
          // note: MAX_PARTICLES is constant above; to change runtime you can alter AREA_PER_PARTICLE externally
          console.warn('To change particle behavior, edit AREA_PER_PARTICLE or MAX_PARTICLES in source code.');
        },
        pause(){
          cancelAnimationFrame(rafId);
        },
        resume(){
          if (!reducedMotion) rafId = requestAnimationFrame(loop);
        }
      };

    })();
  </script>
</body>
</html>
